# 宏观问题

## 1.C和C++的区别？

1. C语言：是一种过程化编程语言，主要强调函数和过程的使用。C++语言：是一种支持多种编程范式的语言，包括面向对象编程（OOP）、过程化编程和泛型编程。
2. C语言不支持多态。C++支持静态多态和动态多态。
3. C语言使用malloc/free手动管理内存；C++除了使用new/delete手动管理内存，还提供了智能指针和RAII等机制，可以更安全的管理资源，避免内存泄漏。
4. C++的标准库更大，包含了STL，提供了常用的数据结构和算法，使开发高效。
5. C语言依赖返回值和错误码处理异常；C++提供了异常处理机制（try, catch, throw），使得错误处理更为集中和规范，代码更加清晰。

## 面向对象和面向过程的优缺点对比

面相过程：优点：效率高，不需要实例化对象。缺点：耦合度高，扩展性差，不易维护。

面相对象：有点：耦合度地，扩展性强，易维护，封装继承多态有助于设计低耦合的系统。缺点：效率比面向过程低。

## 三大特性可以说一下吗？

1. 封装
   1. 将数据和函数组合在一个类中的过程。
   2. 主要目的是隐藏类的内部实现细节，仅暴露必要的接口给外部。
   3. 控制类成员的访问级别，限制对类内部数据的直接访问，确保数据的完整安全。
2. 继承
   1. 一个类从另一个类获得其属性和方法的过程。
   2. 继承允许我们创建具有共享代码的类层次结构，提高复用性和可维护性。
   3. 访问修饰符控制了派生类对基类成员的访问权限。
3. 多态
   1. 不同类的对象使用相同的接口名，但有不同的实现。
   2. 多态通过虚函数和抽象基类实现。
   3. 虚函数允许派生类重写基类的方法，而抽象基类至少包括一个虚函数，不能被实例化，只能作为其他派生类的基类。
   4. 通过多态，我们可以编写更通用、可扩展的代码，提高代码的灵活性。

## 2.C可以实现面向对象吗？

1. 在C中，可以使用 `struct` 来模拟类，`struct` 可以包含数据成员和函数指针。通过将数据和操作封装在 `struct` 中，可以模拟类的行为。
2. C不直接支持继承，但可以通过组合（Composition）和函数指针模拟继承行为。子类结构体可以包含基类结构体，借此实现类似继承的行为。
3. 通过函数指针数组，可以实现动态多态性。可以在运行时根据具体对象类型调用不同的函数，实现类似虚函数的行为。

## 3.介绍下 C++程序从编写到可执行的整个过程?

1. 编写代码:编写C++源代码，保存为 .cpp、.cc、.h文件。
2. 预处理:预处理器根据源代码中的预处理指令(如 #include 替换、 #define 替换等)对代码进行处理，**生成纯净的源代码**
3. 编译:编译器(如 g++或 clang++ )将预处理后的源代码翻译成汇编代码。
4. 汇编:汇编器(如 as )将汇编代码转换成机器码，生成目标文件(.o文件)
5. 链接:链接器(如 1d)将多个目标文件和库文件链接在一起，生成最终的可执行文件。

## 4.动态链接和静态链接的区别？

1. **静态链接**是在编译时将目标文件中的函数调用与库中对应的函数实现进行绑定，并将这些代码直接复制到最终的可执行文件中。
   1. 独立性：静态链接生成的可执行文件在运行时完全独立，不依赖外部的库文件。
   2. 空间浪费：由于所有被引用的库函数代码都被复制到可执行文件中，所以生成的可执行文件通常较大。
   3. 更新困难；当库函数的代码修改，就要重新进行编译链接形成可执行程序。
2. 动态链接：在动态链接中,程序中的函数调用并不会在编译或链接阶段被直接绑定到具体的函数实现上。而是在**程序运行时**,由操作系统的**动态链接器**负责将这些函数调用与共享库中的函数实现进行绑定。这个过程称为**延迟绑定**。
   1. 共享库：动态链接依赖于操作系统提供的共享库(也称为动态链接库,DLL 或 so 文件)。共享库包含了程序所需的函数实现,可以被多个程序共享使用。
   2. 更新灵活：由于函数调用在运行时才被绑定,因此可以在不重新编译应用程序的情况下,更新共享库中的函数实现。下次运行时，新的目标文件会被自动加载到内存并链接进来。
   3. 性能损耗：将链接推迟到了程序运行时，每次执行程序都要进行定位共享库、动态绑定函数调用等过程。所以性能有一定的损失。

## 5.什么是大端序？什么是小端序？怎么区分？为什么有两种？

1. 大端序：数据高字节，存储在低地址。

2. 小端序：数据高字节，存储在高地址。

3. 大端序更符合人类的阅读习惯，广泛用于网络协议，而小端序在某些硬件操作中效率更高，低字节存储在低地址。

4. 区分：*c输出0x12就是大端序

   ```cpp
   unsigned int x = 0x12345678; 
   char* c = (char*)&x;
   ```

## 6.include<a.h>和include "a.h"的区别？

1. include<a.h>:编译器会在预定义的系统目录中搜索头文件，这种路径搜索方式适用于标准库和第三方库的头文件。
2. include "a.h":编译器会在当前源文件所在目录和自定义目录中搜索头文件

## 7.是否可以include的源文件？

可以 include 源文件。但是不推荐。

1. 代码组织和维护:头文件(.h)通常用于声明，而源文件(.pp)用于实现。如果include 源文件，**会导致代码的组织变得混乱，难以维护和理解**。
2. 模块化设计原则:头文件和源文件的分离是为了遵循模块化设计原则，有助于减少耦合。
3. 潜在的链接问题:include 源文件可能会导**致多重定义问题**，这会在链接阶段引发错误。

## 8.命名空间的作用？怎么用？

命名空间主要用于解决名字冲突，项目规模大的时候，函数、类容易出现相同名字。

## 9.怎么理解ifdef endif

条件编译。有时希望当满足一个条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。

```cpp
#ifdef 标识符  
程序段1  
#else  
程序段2  
#endif
标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2.
    else可以不存在
```

在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。

## 10.临时对象什么时候产生？

1. 以值传递的方式给函数传参。
2. 在函数返回对象时候，会创建一个临时对象接收这个对象;
3. 在显式或隐式类型转换过程中,会产生一个临时对象来保存转换结果。
4. 运算符重载会产生临时对象。

# 指针相关

## 1.什么是RAII？

资源获取即初始化，它的核心思想是将资源的获取与对象的生命周期绑定，通过构造函数获取资源(如内存、文件句柄、网络连接等)，通过析构函数释放资源。这样，即使程序在执行过程中抛出异常或多路径返回，能确保资源正确释放，可以避免内存泄漏。

1. 内存管理: 标准库中的 std::unique ptr和 std::shared ptr 是RAII的经典实现，用于智能管理动态内存。
2. 文件操作: std::fstream 类在打开文件时获取资源，在析构函数中关闭文件。
3. 互斥锁: std::lock_guard 和 std::unique_lock 用于在多线程编程中自动管理互斥锁的锁定和释放

## 2.常用的三种智能指针？

1. unique_ptr

   unique_ptr是一种独占所有权的智能指针，同一时间内只能有一个 unique_ptr 指向一个特定的对象。当 unique_ptr被销毁时，它所指向的对象也会被销毁。
   
   不可复制，可以move。unique_ptr可以作为返回值，会调用移动语义。
   
2. shared_ptr

   共享所有权，内部使用引用计数来确保只有当最后一个指向对象的shared_ptr被销毁，对象才会被销毁。

   make_shared的优点：

   1. 简化代码。
   2. 只进行一次内存分配，传裸指针需要创建临时对象，再创建shared_ptr.
   3. 降低内存泄漏风险。make_shared是全有或者全无，抛出异常不担心内存泄漏。
   
   ```cpp
   std::shared_ptr<A> sp1 = std::shared_ptr<A>(new A());
   std::shared_ptr<A> sp2 = std::make_shared<A>();
   ```
   
3. weak_ptr

   一种不拥有对象所有权的智能指针，它指向一个由 shared_ptr 管理的对象，且不增加引用计数。weak_ptr 用于解决 shared_ptr 之间的循环引用问题.
   
   它提供了一种观察资源但不拥有资源的手段。
   
   weakptr不能直接访问指向的对象，需要用lock将weakptr转换成sharedptr再访问。如果weakptr指向的对象已经销毁，lock会返回空的sharedptr。

## 3.shared_ptr的引用计数什么时候会增加，什么时候会减少？

增加：1.构造(默认构造、拷贝构造)的时候引用计数增加 2.拷贝赋值的时候引用增加. 

减少：1.正常销毁2.指向了另一个资源对象  3.值传递结束  4.reset释放对对象的控制 

## new一个指针，分别传给两个shared_ptr会怎样

会有未定义的行为或双重释放的问题。分别初始化两个独立的 `shared_ptr`，那么每个 `shared_ptr` 都会认为自己是该指针的唯一拥有者，不能共享引用计数。一般使用拷贝构造或者赋值运算符来共享引用计数。

## 4.shared_ptr是不是线程安全的？

1. shared ptr 的引用计数是线程安全的
2. 它管理的对象是否线程安全，不归shared ptr 来管，取决于相关的对象是否有做同步处理!

## 4.智能指针的缺点？

1. 性能开销。会增加一些性能开销，因为它们需要维护引用计数。
2. 循环引用。可能会导致内存泄漏或对象未能及时销毁。
3. 内存占用。智能指针对象自身占用内存，并且 `shared_ptr` 和 `weak_ptr` 还需要额外的空间来存储控制块（包含引用计数等）。

## 5.什么时候用智能指针？什么时候用裸指针？

1. 智能指针
   1. 资源需要明确的生命周期管理。
   2. 需要防止内存泄漏。
   3. 管理复杂对象的生命周期和所有权。
2. 裸指针
   1. 不需要管理资源生命周期。
   2. 性能敏感的场合。
   3. 处理简单的对象引用。

## 6.this指针的作用？

1. 访问类的成员变量和成员函数，特别是当局部变量与成员变量同名时，用 this 指针可以明确的区分出来。
2. 链式调用:可以通过返回 *this 来支持链式调用。
3. 动态绑定:在基类指针或引用调用派生类对象时，利用 this 指针可以直观的实现动态绑定。

## 7.引用成员变量是否占用空间？

对象的引用成员使用指针实现。

## 8.指针和引用的区别？

1. 指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。
2. 指针可以在定义的时候不初始化；引用在定义的时候必须初始化。
3. 指针可以被重新赋值，指向不同的变量；引用在初始化后不能更改，始终指向同一个变量。
4. 指针可以为 nullptr，表示不指向任何变量；引用必须绑定到一个变量，不能为 nullptr。
5. 指针作为函数参数，要检查是否为空；引用不用。
6. 使用指针需要对其进行解引用以获取或修改其指向的变量的值；引用可以直接使用，无需解引用。
7. sizeof得到指针的大小；sizeof得到引用代表对象的大小。
8. 指针++操作指向下一个地址，移动步长和指针类型有关；引用++操作改变当前对象。

总结：从汇编层面说，引用只是C++语法糖，可以看作编译器自动完成取地址、解引用的指针常量。

## 9.void指针？

不能对void指针解引用，因为解引用的本质就是编译器根据指针所指的类型，然后从指针所指向的内存连续取 N 个字节，然后将这 N 个字节按照指针的类型去解释。

## 10.什么是野指针和悬挂指针？

野指针是一个**未被初始化的指针**，可能指向任意内存地址。

悬空指针是指向**已经被释放（如删除、回收）的内存的指针**。访问悬空指针会导致未定义行为。

为了避免野指针和空悬指针引发的问题，我们应该：

1. 在使用指针前对其进行初始化，如将其初始化为nullptr。
2. 在释放指针指向的内存后，将指针设为nullptr，避免误访问已释放的内存。
3. 在使用指针前检查其有效性，确保指针指向合法内存。

## 11.什么是深拷贝和浅拷贝？

1. 浅拷贝

   浅拷贝只拷贝指针，不会拷贝指针指向的内存，拷贝的指针和原来指针指向相同的内存。如果原来的指针将资源释放，再释放拷贝指针时就会引发错误（此时的拷贝指针已经是悬空指针）。

2. 深拷贝

   深拷贝不仅拷贝对象的指针，还拷贝指针指向的内存。在实现拷贝操作时，如果有指针变量就需要自己来实现深拷贝。

## 12.什么是零拷贝？

**零拷贝**（Zero-Copy）是一种优化技术，旨在减少数据在不同内存区域之间的拷贝次数，从而提高系统的性能。

1. **sendfile**：在 Linux 中，通过 sendfile，应用程序可以直接将文件数据从文件系统传输到网络套接字或者目标文件，而无需经过用户缓冲区和内核缓冲区。
2. **用户态和内核态之间的共享内存(mmap)**：通过共享内存区域，避免了用户态与内核态之间的数据拷贝。
4. **splice**：允许将数据在内核中的缓冲区之间移动，而不需要复制到用户态。 
4. **DMA（直接内存访问）**：DMA 可以直接将数据从内存传输到外设，或者从外设传输数据到内存，避免了数据在用户态和内核态之间的多次拷贝。

# 虚函数多态面相对象

## 1.什么是虚函数？C++中虚函数的原理？

虚函数是实现多态关键机制。虚函数允许在基类中使用virtual声明一个函数，在派生类中可以对其进行重新定义。通过虚函数，CPP可以根据对象的实际类型调用派生类的函数实现。

虚函数的关键在于**虚指针**和**虚函数表**。有虚函数的类就有虚函数表，虚函数表中存有该类的虚函数地址。每个对象有一个虚指针，指向类的虚函数表。调用虚函数时，this->vptr->vpt->virtualFunction。

## 2.什么函数不能声明为虚函数？

构造函数、静态函数、内联函数、友元函数、模版函数。

## 3.构造函数可以是虚函数吗？

1. 虚函数是要用于实现多态的，在派生类中覆盖基类的虚函数。但是构造函数负责初始化对象的成员，在派生类中需要调用基类的构造函数用于初始化基类的成员。因此，**构造函数没有被覆盖的必要。**
2. 虚函数依赖于vtable和vptr，然而在调用构造函数时，对象还没有完全创建和初始化，所以虚指针还未设置，调用虚函数可能导致未定义的行为，只有执行完对象的构造，虚指针才会被正确的初始化。

## 4.析构函数一定要是虚函数吗？

不一定。作为基类有虚函数可以。基类指针指向派生类对象，通过delete基类指针删除对象时，只调用基类的析构函数，派生类的资源没有被析构。所以需要将基类的析构函数定义为虚函数，析构顺序是派生类、基类。

## 5.虚函数继承时遇到默认缺省参数会出现什么结果，怎么避免。

默认参数是编译期绑定的，其值是根据指针的**静态类型**来确定的。可能会引发意外行为。

1. 虚函数避免使用默认参数。2.只在基类使用默认参数。3.显式参数调用。

## 6.C++的虚函数表在哪个阶段被分配的，存在哪里？

1. **虚函数表的创建：**在编译阶段，编译器为包含虚函数的类创建虚函数表，其中包含指向虚函数的指针。虚函数表是个数组。
2. **虚函数表的分配：**在链接阶段，**虚函数表被分配具体的内存地址**。链接器会将所有虚函数表放入**全局内存空间**中，确保每个虚函数表都有唯一的内存地址。
3. **虚表指针的初始化：**在运行时，当类的对象被实例化时，**虚指针（vptr）被初始化**，指向对应类的虚函数表。vptr 存在于对象内存布局的最前面。

## 7.什么是多态？怎么实现？

一个接口有多个不同的实现。同一个函数调用，可以根据上下文执行不同的功能。

1. 静态多态
   编译期间的多态，包括**函数重载和函数模板**。根据函数实参类型推断要调用的函数。

   1. 函数重载

   2. 函数模版：模板函数可以根据传递参数的不同类型，**自动生成相应类型的函数代码**。

2. 动态多态

   运行时的多态，在执行期间判断引用对象的实际类型，根据实际类型调用相应的方法。

   使用**基类的引用或指针**指向派生类对象时，通过虚函数的机制，可以调用到派生类中重写(override)的函数，从而实现多态。

   - 必须通过**基类的指针或者引用**调用虚函数
   - 被调用的函数是**虚函数**。

## 8.重载(overloading)、重写(override)、隐藏(覆盖Hide)

1. 重载。重载是指相同作用域内有相同的方法名，但是参数类型或参数数量不同的方法。参数类型和参数数量都相同时，返回类型不作为区分条件。
2. 重写。重写是指派生类重新定义了基类中已有的虚函数，以改变其行为。重写函数在基类中是虚函数，且在派生类中具有相同的函数名称、参数列表和返回类型。
3. 隐藏。隐藏是指派生类屏蔽了同名的基类函数。函数同名：
   1. 参数列表和返回类型相同，基类函数不是虚函数。(如果基类函数是虚函数，就是重写了)。
   2. 参数列表和返回类型不完全相同。

## 9.虚函数内部调用非虚函数是调用指针类还是对象类？

非虚函数的调用是静态绑定的，即在编译时就已经确定了调用哪个函数。因此，当虚函数内部调用非虚函数时，**调用的是当前对象所属类的非虚函数。**

## 10.什么是虚继承？(什么是菱形继承)

虚继承主要用于解决“菱形继承”问题，避免多个派生类继承自同一个基类时带来的重复和冲突。

## 11.什么是纯虚函数？它与虚函数有何不同？

基类中声明但不实现的虚函数，目的是定义一个接口。

1. 包含纯虚函数的类是抽象类，不能实例化对象。
2. 确保了派生类提供了必要的功能，否则该派生类也将成为抽象类，无法实例化。

不同：虚函数有默认实现；虚函数可以实例化；派生类可以不重写虚函数。

## 12.C++成员模版函数为什么不能是virtual的？

当一个virtual函数是模板函数时，编译器在编译时无法为其生成一个确定的虚函数表条目，因为模板函数可以有无数个实例。但是编译时无法确定需要调用哪个特定的模板实例。

## 13.虚函数的调用过程与普通函数调用有何不同？

1. **普通函数**：采用静态绑定，编译时就确定了函数地址，调用过程简单、开销小。
2. **虚函数**：采用动态绑定，依赖 `vptr` 和 `vtable` 在运行时查找目标函数，实现多态性。虚函数调用过程比普通函数复杂一些，开销也略高。

## 14.友元类和友元函数的作用？

提供访问私有成员和保护成员的权限，并不会破坏封装性。

## 15.什么场景用继承？什么场景用组合？

在C++中，继承和组合是常用的两种实现代码复用和构建复杂对象的技术。

1. 继承:使用场景:
   1. 当需要表示一种“is-a”(是一个)关系时。
   2. 当我们需要对基类的行为进行扩展或修改，并且能够利用多态性时。
   3. 当基类提供了一些通用的功能，而派生类则基于这些功能进行进一步的特化。
2. 组合:使用场景:
   1. 当需要表示一种“has-a”(有一个)关系时。
   2. 当我们需要复用其他类的功能，而不是继承它们。这样可以避免因为继承带来的过度耦合。

## 16.类的初始化顺序？

1. 基类初始化。
   当前类继承的基类按照声明顺序进行初始化，如果有虚继承优先虚继承。
2. 成员变量初始化。
   按照在类定义中的声明顺序进行初始化。如果没有成员初始化列表就是默认构造函数或者是内置类型默认的垃圾值。
3. 基类和变量初始化完就执行构造函数的函数体。
4. 类的析构顺序与构造顺序完全相反：析构派生类，析构类成员，析构基类。

# 内存相关

## 1.C++的内存模型？

![image-20240813151212265](.\0.CPP汇总.assets\image-20240813151212265.png)

**栈：**由编译器管理分配和回收，存放局部变量和函数参数。 
**堆：**由程序员管理，需要手动 new malloc delete free 进行分配和回收，空间较大，但可能会出现内存泄漏和内存碎片的情况。 
**全局/静态存储区：**分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。 
**常量存储区：**存储常量，一般不允许修改。 
**代码区：**存放程序的二进制代码

全局变量和静态变量会自动初始化，局部变量值是未定义的。默认生成的构造函数对于内置类型不会自动初始化，值是未定义的。

说⼀下 C++ ⾥是怎么定义常量的？常量存放在内存的哪个位置？  对于局部常量，存放在栈区； 对于全局常量，编译期⼀般不分配内存，放在符号表中以提⾼访问效率； 字⾯值常量，⽐如字符串，放在常量区。

## 2.malloc/free、new/delete

1. 两者的区别
   1. malloc是C标准库函数；new是CPP的操作符。
   2. malloc手动计算分配空间；new自动计算分配空间大小。
   3. malloc不是类型安全，分配失败返回NULL；new类型安全，分配失败抛出异常。(bad_alloc)
   4. new会分配空间并执行构造函数；malloc只分配空间。
2. new和delete的实现
   1. new
      1. 调用operator new分配足够的空间；
      2. 在空间上调用构造函数，并传入初值。
      3. 返回指向对象的指针
   2. delete
      1. 调用对象的析构函数
      2. 调用operator delete释放内存空间
   3. delete[] 和new[]配套使用
      1. 对于没有ptr的成员，delete不加[]也没影响，
      2. delete[3]会调用三次析构函数，清空指针指向空间的内容。
      3. delete[]，按照数组中元素的逆序进行销毁。
3. operator new(size_t) 和 operator delete(void*, size_t)
   1. 两个C++函数可以重载，在类中重载(静态)。
   2. ::new 和 ::delete会绕过重载。
   3. 不要重载::operator new / ::operator delete
   4. ::operator new / ::operator delete调用malloc/free
4. glibc的malloc
   1. glibc用称为bins的自由链表管理内存，分配时从相应大小的链表找。每个bin存储特定大小的空闲块。
   2. 如果没有bin可以满足，就检查top chunk，从中取用内存，再不够就brk分配。
5. free回收的内存
   1. brk系统调用得到的内存不会立即还给操作系统，会由双链表保存。
   2. `free` 的本质是将动态分配的内存块归还给堆管理器，使其可以重新分配，不会清除其中的值。
## 3.什么情况下会出现内存泄漏?如何避免内存泄漏?

内存泄漏：申请了内存但是未释放。

1. 经典场景
   1. 对象创建后却没有释放。
   2. 内存管理关键字使用不配对：new[] 和 delete配对用。
   3. 智能指针的循环引用，两者互相持有，导致引用计数永不为0，内存无法释放。
   4. 在外面手动申请的内存，但进入了**异常处理**，手动分配的内存未释放。
   
2. 避免内存泄漏的方法
   1. 使用智能指针，自动管理内存。
   2. RAII原则，在构造函数分配资源，析构函数释放
   3. new和delete对应，malloc和free对应。
   4. 避免循环引用，用weakptr解决。
   5. 用静态分析工具和内存检测工具(Valgrind)来检测内存泄漏。
   
3. valgrind检测内存泄漏 memcheck工具

   ```cpp
   valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./your_program
   --leak-check=full：进行内存泄漏检测并给出每个泄漏的详细信息。
   --show-leak-kinds=all：报告所有类型的内存泄漏。
   --track-origins=yes：跟踪未初始化值的来源，有助于发现使用未初始化内存的错误。
   ```

## 4.C++ 中为什么 new[] 和 delete[]一定要配对使用?

`new[]` 分配内存并调用多个对象的构造函数，而 `delete[]` 负责调用每个对象的析构函数并释放内存。如果不正确配对使用，可能导致内存泄漏或未定义行为。

## 5.C++中 malloc 申请的内存，可以用 delete 释放吗?

不能，否则会导致未定义行为，可能会导致程序崩溃或其他严重错误。

## 6.new的类型

```cpp
1.普通的new
    char *p = new char[10];
    int *p = new int();// 默认初始化为0
2.nothrow new： 空间分配失败情况下不抛出异常，而是返回null
    char *p = new(nothrow) char[10e11];
3.placement new：在一块已经分配成功的内存上重新构造对象。
    char *p = new(nothrow) char[sizeof ADT + 1];
    ADT *q = new(p) ADT; 
    q->ADT::~ADT();//显式调用析构函数
    operator delete[] p;
    placement new构造的对象数组要显式调用析构函数销毁，不能用	           delete，因为大小不一定等于原来分配的大小。
```

## 7.malloc、realloc、calloc

```cpp
1.malloc：分配指定大小的内存   
	void* malloc(unsigned int num_size);
	int *p = malloc(20 * sizeof(int));
2.calloc：分配n个size的内存。
    void* calloc(size_t n,size_t size);
    int *p = calloc(20, sizeof(int));
3.realloc：用于调整先前分配的内存块的大小
	void realloc(void *p, size_t new_size);
    可能在原地重新分配，也可能选一块新的内存，把原来的数据拷贝过去。用返	  回的新指针更新旧指针。 
```

## 8.C++中memcpy和 memmove 有什么区别?

用于从源地址复制指定数量的字节到目标地址。memcpy更快。

1. memcpy:如果源和目标地址重叠，行为是未定义的，因为 memcpy 不处理重叠。
2. memmove:它可以安全地处理源和目标地址的重叠情况。memove 保证重叠情况下的数据也是被正确地复制。

## 9.memcpy和strcpy什么区别?

1. **memcpy**：用于内存块拷贝，复制指定长度的内存块。(单位：字节)。
2. **strcpy**：用于拷贝字符串，它会从源字符串复制字符到目标字符数组，直到遇到终止符'\0'

## 10.什么是内存对齐？为什么要内存对齐？

内存对齐是计算机在访问内存的时候，根据一些规则为数据指定一个合适的起始地址，通常，这个地址是固定数字的整数倍。

1. 减少CPU周期：对齐的数据访问通常只需一个CPU周期，而未对齐的数据访问可能需要多个CPU周期。未对齐的访问需要额外的处理步骤，如拆分和合并数据，这会增加CPU的工作负担。通过字节对齐，可以简化内存访问操作，减少CPU周期，提高程序运行效率。
2. 避免跨边界访问：通过字节对齐，数据可以存放在单一的内存单元中，避免跨越边界访问，从而提高内存访问效率。
3. 内存对齐可以避免因未对齐的内存访问导致的程序崩溃和CPU异常。
4. 内存对齐可以使CPU缓存系统更高效的工作，减少缓存未命中的概率。

`#pragma pack(n)` 设置的对齐方式。`#pragma pack()` 取消设置。 
alignas可以指定对齐大小。alignas 的参数应为 2 的非负整数次幂,且不能小于默认对齐方式。alignof可以输出对齐大小。

## 11.C++中堆内存和栈内存的区别？

1. 分配方式:
   栈内存:由编译器在程序运行时自动分配和释放。
   堆内存:需要程序员手动分配和释放。
2. 管理方式:
   栈内存:由编译器自动管理，无需担心内存泄漏，生命周期由作用域决定。
   堆内存:由程序员手动管理，如果没有正确释放内存，会导致内存泄漏。
3. 生命周期 
   栈内存:变量在离开作用域之后自动销毁。
   堆内存:只要不手动释放，内存会持续存在，直到程序终止。
4. 性能:
   栈内存:内存分配和释放速度极快，性能上优于堆内存。
   堆内存:涉及到复杂的内存管理和分配机制，性能上较慢。

## 12.C++的栈溢出是什么？如何防止？

linux下栈内存8M，windows下1M。

1. 无限递归 ：没有终止条件，栈帧无限增长。
2. 分配过大的局部变量：在栈上分配过大的局部变量（如数组）会占用大量的栈空间，导致栈空间不足，发生栈溢出。

解决：

1. 使用动态内存分配:对于需要大内存的局部变量，考虑使用堆代替栈。
2. 控制递归深度:通过增加递归深度限制条件，避免无限递归的发生。
3. 增大栈空间:在某些情况下，可以通过操作系统或编译器选项增大栈的大小。

## 13.C++中内存访问越界会怎样？

1. **未定义行为**：内存访问越界是C++中的未定义行为。程序可能会表现出各种不可预期的行为，取决于内存布局、操作系统以及编译器的优化。可能的结果包括程序崩溃、输出错误数据、引发安全漏洞等。
2. **程序崩溃**：如果访问的内存地址不属于程序的地址空间（如非法的指针访问），操作系统可能会终止程序，并抛出“段错误”（Segmentation Fault）。
3. **数据损坏**：如果访问的内存地址属于程序的其他变量或数据结构，可能会导致其他数据被意外修改，从而导致逻辑错误或数据损坏。
4. **安全漏洞**：内存越界是许多安全漏洞（例如缓冲区溢出攻击）的来源。攻击者可以利用越界访问来修改内存，注入恶意代码，进而控制程序的执行。

## 14.怎么避免内存访问越界？

1. 使用标准库容器。使用`std::vector::at()`代替`operator[]`进行访问。`at()`会进行边界检查，如果访问越界会抛出异常。
2. 在动态内存分配时，使用智能指针（如`std::unique_ptr`、`std::shared_ptr`）来管理动态内存，避免错误访问被释放的内存。
3. 用`Cppcheck`静态分析工具来检测可能的越界访问。


## 15.C++的六种内存序

内存序是C++并发编程中的知识点，它可以控制多线程程序中变量之间的访问顺序。C++11标准引入了六种内存序，程序员可以针对不同的场景选择合适的内存操作语义。这六种内存序分别是

1. memory_order_relaxed:这是最弱的内存序，不保证任何跨线程的同步，仅保证原子操作的原子性，不保证同步的顺序(因为可能涉及到指令重排序)。适用于无需跨线程的同步场景。
2. memory_order_consume:比 memory_order_relaxed 稍强，但仅在数据依赖的场景下有序(已经在很多编译器中被 memry_order_acquire 代替)。
3. memory_order_acquire :读取操作在此之前的所有操作在它之前执行。适用于获取锁或同步操作需要确保先前的操作完成.
4. memory order release :写入操作在此之后的所有操作在它之后执行。常用于解锁操作，确保之前的操作都完成后才释放锁。
5. memory_order_acq_rel:结合 memory_order_acquire 和 memory_order_release 的语义，用于读-改-写操作，确保读取之前的操作在它之前完成，写入之后的操作在它之后进行。
6. memory_order_seq_cst:这是最强的内存序，保证所有线程的操作按严格的全局顺序进行。适用于需要严格顺序的场景，通常是默认选择。

# 关键字相关

## 1.static的作用？

1. 修饰全局变量或函数：限制变量和或函数的作用域，只能在定义的文件内部访问，有助于避免不同文件之间的命名冲突。
2. 修饰局部变量：①变量的存储位置在程序执行期间保持不变让②只初始化一次。
3. 修饰类内成员变量和函数
   1. ①被修饰的成员变量和成员函数属于类本身，所有对象共享。②先于对象存在，要在类外初始化。
   2. static函数只能调用static变量，不能被virtual修饰。可以传递类对象的指针或引用来调用非static变量。

## 2.const的作用？

1. 修饰变量。将一个变量声明为常量，初始化之后不能修改。
2. 修饰函数。①修饰返回值。返回值是个常量，不能改变；②修饰形参。形参是常量，不能改变。
3. 修饰指针。①指向常量的指针：const int* ptr;②常量指针：指针本身是一个常来那个，不能改变指向。int* const ptr;③指向常量的常量指针：const int* const ptr;
4. 修饰类成员变量和类成员函数。
   1. 修饰成员变量为常量，要在构造函数中初始化。
   2. ①修饰成员函数用来防止在操作中改变对象的内容②const对象只能用const成员函数来操作。
5. 顶层const修饰内容本身。底层const修饰指针或引用的对象。const_cast用于去除底层const。

## 3.mutable

用来修饰类的成员变量，添加mutable的成员变量可以在const函数中被修改。

## 4.explicit

防止**构造函数**或**转换函数**在不合适的时候被隐式调用。

1. 单参数的构造函数可能进行隐式转换来创建实例。

2. 转换函数,类中有时会定义转换函数，可以用explicit来防止转换。

   ```cpp
   class Double {
   public:
       explicit operator int() const {
           return static_cast<int>(value);
       }
   private:
       double value;
   };
   ```

## 5.extern

1. extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。
2. 在头文件中声明变量,必须加上extern，否则就是重定义。

## 6.extern"C"

1. 使用 extern "C" 声明的函数或变量会采用 C 语言的链接规则，即**符号的名称和调用约定**与 C 语言相同。
2. C++中使用自定义的C函数，可以用extern "C"声明这些函数按照C语言方式处理。
3. C语言调用C++函数，用extern"C"修饰C++的函数，用C语言的链接规则。

## 7.inline作用

建议编译器将函数调用替换成函数体，减少函数调用的开销。

1. 优点：①降低函数调用的开销。②提高代码执行效率。
2. 缺点：①代码膨胀。②只是建议，编译器可以忽略inline。

内联函数与宏的区别:①宏是在预处理阶段进行文本替换，而内联函数是在编译阶段展开。②内联函数有类型安全和作用域控制，宏没有这一特性。③内联函数可以更好地报告调试信息，相对来说调试比较方便。

## 8.final

防止类被继承或防止虚函数被覆盖。避免不必要的继承和函数重写。

## 9.override

用于明确声明派生类中的函数是重写基类的虚函数。

1. 可以防止派生类中写错了函数的参数，导致和基类不匹配。
2. 可以防止基类函数未声明为虚函数。

## 10.volatile

作用：告知编译器某个变量可能会在程序的其他地方被改变，防止编译器对这样的变量进行优化，保证每次的访问都会直接从内存中读取或写入。

1. 硬件编程。变量映射到硬件寄存器，硬件设备可能会在后台改变寄存器值
2. 多线程编程。表示变量会被其他线程修改。确保每次都从内存中读取值

## 11.sizeof和strlen的区别？

1. sizeof是运算符，用于获取一个类型或者对象的内存大小。在编译期获得结果。
2. strlen是库函数，用于计算C风格字符串的长度，不包含\0结束符。参数只能是C风格字符串的指针，在运行时获得结果。

## 12.define和const的区别？

1. define是预处理指令，在预处理阶段进行文本替换。没有类型检查，调试困难。没有作用域。
2. const是关键字，在编译时确定类型和值。类型安全。有作用域。

## 13.using和typedef的区别？

都是用来为已有类型定义一个新的名称。

using可以用来定义模版别名，typedef不能。

## 14.C++中class 与 struct的区别？

1. struct的默认访问权限和默认继承权限是public；class的默认访问权限和默认继承权限是private。
2. class 可以用于定义模板类，struct 不能用于定义模板类。

## 15.struct在C与C++中的不同？

1. C语言中，struct是用户自定义数据类型；CPP中，struct是抽象数据类型，支持成员函数的定义。
2. C中struct没有权限的设置；CPP中struct可以设置访问权限。
3. C中struct在声明类型要加上struct关键字；CPP可以直接使用结构体名。

## 16.结构体struct和联合体union的区别

1. 内存分配：每个成员有自己的内存空间；所有成员共享同一块内存区域。
2. 大小：所有成员的大小之和；最大成员的大小；
3. 使用场景：存储不同但相关的数据；存储多种类型的数据，但一次只用一种。
4. 访问：可以同时访问多个成员。 只能访问当前存储的成员。

## 17.enum和enum class的区别？

1. 作用域:
   enum :在定义枚举后，可以直接使用枚举成员，而不需要前缀

   enum class: 枚举成员要**使用枚举名作为前缀来访问。**

2. 类型安全:
   enum :传统枚举类型不安全，枚举成员会隐式转换为整数类型。
   enum class: 强类型枚举是类型安全的，不能隐式转换为其他类型，必须显式转换。

## 18.delete和default

1. delete用于显式的删除某个函数的默认实现，禁止它的使用。
2. default用于显式的要求编译器生成某个函数的默认实现。

# 函数及其他

## 1.函数调用原理是什么？什么是栈帧？

栈帧：每次函数调用在栈上分配的内存区域。包括：形参、返回地址、局部变量、上下文信息(调用者的栈指针和寄存器等状态信息)。

1. 保存当前上下文。调用指令将返回地址压入栈中，可能还会保存一些需要的寄存器状态。
2. 分配栈帧。调整栈指针，为被调函数分配栈帧，用于存储局部变量、参数等。
3. 传递参数。根据调用约定，通过寄存器或栈传递参数给被调函数。
4. 跳转到被调函数的代码。PC被更新为被调函数的入口地址。
5. 执行被调用函数。运行函数体的代码。
6. 返回调用点。函数执行完毕后，恢复保存的寄存器状态，调整栈指针恢复返回地址，跳转回主调函数继续执行。

## 2.什么是回调函数？为什么需要回调函数？

回调函数就是将函数的调用权从一个地方转移到另一个地方，这个调用会在未来某个时刻进行，而不是立即执行。

1. 异步编程。比如网络请求、文件读取等。在操作完成后调用函数，主程序可以继续执行其它任务，避免等待操作完成。
2. 解耦代码。有助于将代码模块化和解耦，允许我们创建更灵活和可复用的代码。
3. 事件驱动编程。在事件驱动程序中，可以用回调函数处理用户的输入事件

## 3.C++中值传递和引用传递的区别？

1. 值传递:①会触发一次参数的拷贝动作，所以对参数的修改不会影响原始的值。②如果是较大的对象，复制整个对象，效率较低。
2. 引用传递:函数接收的就是参数的引用，不会触发参数的拷贝动作，效率较高，但对参数的修改会直接作用于原始的值。

## 4.函数调用的压栈

1. 从入口函数main开始执行，操作系统的运行状态、main函数的返回地址、main的参数、main的变量，依次进行压栈。
2. mian函数中调用函数func，编译器将main函数的运行状态进行压栈。func函数的返回地址、参数从右到左、func定义的变量依次压栈。
3. func函数调用函数f，编译器将func函数的运行状态压栈，再将f的返回地址、参数从右到左、f定义的变量依次压栈。

## 5.四种类型转换

1. static_cast<new_type> (expression) 在**编译时执行类型转换**。没有运行时类型检查来保证转换的安全性。
2. const_cast<new_type> (expression).new_type必须是一个指针、引用或者指向对象类型成员的指针。可以去掉对象的const。
3. reinterpret_cast<new_type> (expression).用于不同类型之间进行低级别的转换。**仅仅是重新解释底层比特而不进行任何类型检查。**reinterpret_cast 运算符并不会改变括号中运算对象的值，而是对该对象从位模式上进行重新解释
   指针类型会教导编译器如何解释某个特定地址中的内存内容及其大小
4. dynamic_cast<new_type> (expression).应用于父子类层次结构中的安全类型转换。**运行时会执行类型检查，相比于static_cast更安全。**
   如果转换失败，dynamic_cast将返回空指针（对于指针类型）或抛出异常（对于引用类型）。dynamic_cast的底层原理依赖于**运行时类型信息**（RTTI, Runtime Type Information）。运行时类型消息与虚表关联。

## 6. 函数对象和普通函数区别？

1. 普通函数通过函数名、函数参数、函数体定义; 函数对象通过重载调用运算符的类实现。
2. 普通函数没有状态，每次调用独立；函数对象可以有状态。
3. 普通函数简单直接，灵活性低；函数对象可以用成员函数定制行为。
4. 普通函数调用高效，可以内联；函数对象开销大。

## 7.什么是可重入函数，什么是不可重入函数？

可重入函数：**可重入函数** 是指一个函数可以被**多个任务**同时调用，而不发生数据不一致或冲突的情况。可重入函数的关键是：**函数内部不使用共享的、非本地的资源**，也不会依赖于外部的状态，函数的行为是完全独立和自包含的。

**不可重入函数** 是指函数在被**多个任务**（线程、中断、进程等）同时调用时，可能会引发数据冲突或不一致的问题。这种函数通常依赖于共享资源，如全局变量、静态变量、或系统资源，而这些资源在并发访问时没有被适当保护。比如：函数依赖于非线程安全的系统资源或函数，如标准 I/O 函数（`printf`）、内存分配函数（`malloc`）。

## 8.给一个main函数和一个f函数，知道他们的offset，怎么去修改main函数中的一个局部变量（f函数没有入参）。

当 `main` 调用 `f` 时，`f` 函数栈帧相对于 `main` 函数的局部变量会有一定的偏移量。这个偏移量可以通过编译器或者调试器来计算。

在 `f` 函数内部，通过栈指针（如 `rbp`(栈基指针) 或 `rsp`(栈顶指针)）加上计算出的偏移量，来访问 `main` 函数的局部变量。 栈基指针内存地址高。

栈从高到低增长，main栈帧的地址高于f函数的栈帧地址。

# 模版

## 1.函数模版和类模板的区别？

1. 函数模板
   定义一个一次性模板，生成多个函数版本。

   根据传入参数，生成具体类型的函数。

2. 类模板

   创建可以接受不同类型参数的类。

   需要显式声明模板类型。

## 2.使用模版的优缺点？

①优点：

1. 代码复用。编写与数据类型无关的代码，减少了重复代码，提高代码重用性。
2. 类型安全。编译时进行类型检查，避免运行时错误，提高安全性。
3. 效率高：编译时生成具体类型代码，避免运行时类型检查，提高运行效率
4. 灵活性强：用来实现泛型编程，实现更通用的算法。

②缺点

1. 编译时间增加，要在编译时生成具体的代码。
2. 错误信息复杂，难调试。
3. 代码的可读性和维护性下降。

## 3.模版什么时候进行实例化？

1. 隐式实例化：模板在编译器遇到模板的具体使用时实例化，如调用或使用时
2. 显式实例化：  显式地实例化某些特定的模板类型：template class  MyContainer<bool>;  
3. 链接时递归实例化：当一个模板依赖于其他模板时,编译器需要递归地实例化所有依赖的模板。

## 4.为什么模板类的定义和实现一般都是放在一个h文件中？

1. **模板类在编译期实例化**：模板类的实例化发生在编译期，编译器需要在实例化模板时看到模板的完整定义和实现。
2. **头文件包含完整定义和实现**：将模板类的定义和实现都放在头文件中，确保编译器在实例化模板时能访问到完整信息，避免链接错误。
3. **避免链接错误**：如果将模板类的实现放在源文件中，可能会导致链接错误，因为编译器在链接阶段无法找到模板实例化的具体实现。在编译时模板的实现并不能生成真正的二进制代码，所以链接程序找不到地址。

# 新特性

## 1.左值&右值、左值引用&右值引用、移动语义、完美转发、std::move

**左值**（Lvalue）和**右值**（Rvalue）是根据表达式是否可以在赋值操作中作为左侧项来区分的，可以取地址、有名字的就是左值。不可以取地址、没有名字的就是右值。

右值分为：①纯右值：字面量、临时对象或表达式的结果②将亡值：表示一个**即将被销毁的对象**，通常与右值引用结合。可以移动（“窃取”）它的资源。

**左值引用**：①被引用者要可以取地址。②使用const可以引用临时变量。

**右值引用**：右值引用是一种可以绑定到右值（rvalue）上的引用类型。右值通常是临时对象或即将销毁的对象，右值引用允许捕获这些右值并对其进行修改。支持移动语义和完美转发。

类型推导发生时(函数模板参数、auto声明)，&&可以表示左值引用或右值引用，此时被称为**万能引用**。

**移动语义**是一种优化资源管理的机制，常规的资源管理是进行拷贝而移动语义允许资源从一个对象转移到另一个对象，而不需要进行深拷贝。移动语义通过移动构造函数和移动赋值运算符实现。使用移动语义可以避免无用拷贝。

**完美转发**允许在模板函数中，将传递给模板函数的参数完美地转发到另一个函数，保持参数的所有属性(左值/右值属性)，从而在合适的情况下启用移动语义，避免误用。使用std::forward<T>实现。

**std::move** 是 C++ 标准库中的一个函数模板，显式的将一个对象的左值转换为右值引用。主要用途是:启动移动语义，从而避免对不必要的复制。原理：通过类型转换将传入的对象转换为右值引用，其本质是`static_cast`类型转换。

## 2.在什么场景下需要用到移动构造函数和移动赋值运算符？

1. 当函数返回一个对象时，用移动构造函数可以避免返回值拷贝。
2. 当函数传递参数时，使用右值 +移动构造函数可以避免参数拷贝。
3. 当需要将一个大对象从一个容器(如vector)移动到另一个容器时，用移动赋值运算符可避免重复的资源分配和释放。

## 3.function、bind、lambda表达式

可调用对象：函数、函数指针、函数对象(仿函数Functor)、function、lambda表达式

function是用来包装可调用对象的，提供类型安全的函数调用，使用function可以明确返回类型和参数类型，得到新的函数对象。提供了类型擦除功能。类型擦除允许 `std::function` 存储和调用任何符合其签名的可调用对象，而不需要知道这些对象的具体类型。

bind是对可调用对象使用，得到新的可调用对象，可以绑定部分参数，便于稍后调用。将 `std::bind` 的返回值赋给 `std::function` 有助于利用 `std::function` 的类型擦除和类型安全特性，使得代码更灵活和简洁。

lambda是定义一个匿名函数。Lambda函数可以在局部范围内定义，并且可以捕获作用域中的变量，从而使得函数的定义更加灵活和简洁。
lambda 表达式的大致原理：每当你定义⼀个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了（）运算符），我们称为闭包类型（closure type）。在运行时，这个lambda表达式就会返回一个匿名的闭包实例，是一个右值。所以，lambda表达式的结果就是一个个闭包实例。闭包的一个强大之处是其可以通过传值或者引用的⽅式捕捉其封装作用域内的变量，称为lambda捕捉块。
闭包带有外部变量的环境，即使外部作用域已经结束，闭包仍然能够访问这些变量。Lambda 表达式本质上是 **闭包类型的构造器**，它定义了闭包的逻辑和捕获方式。

```cpp
捕获列表（按值捕获[=]，引用捕获[&],显式捕获[x, &y]）
参数列表、返回类型、函数体
[capture](parameters) -> return_type {
    // function body
};
```

## 4.thread_local

用于声明一种特殊类型的局部变量,这种变量的生命周期与所属的线程相关联.

- `thread_local` 变量是每个线程私有的,**每个线程都拥有自己的副本**。这意味着在不同的线程中访问同一个 thread_local 变量,实际上访问的是不同线程的副本。

- `thread_local` 变量的内存是由运行时系统自动管理的,开发者不需要手动分配或释放内存。
- `thread_local` 变量天生就是线程安全的。

提供了一种简单而有效的方式来管理线程私有的数据。

 ## 5.std::thread

用于创建和管理线程的类。

```cpp
std::thread t(函数、参数);
```

- `get_id()`: 返回线程的唯一标识符(线程 ID)。
- `joinable()`: 检查线程是否可以被 `join()` 或 `detach()` 调用。
- `join()`: 阻塞当前线程,直到被调用的线程执行完毕。同步机制，保证子进程执行完主进程再继续。
- `detach()`: 将线程与当前线程分离,使其独立执行。子进程可以独立执行
- `swap(other)`: 交换当前线程与 `other` 线程的状态。

## 6.C++的列表初始化

使用{}来初始化变量或对象。

1. 方便。2.初始化列表接受任意长度。3.防止类型窄化。

## 7.RAII lock lock_guard和unique_lock的区别？

RAII形式的锁管理类，用于管理互斥锁。

1. 1ock_guard 是一个简单且轻量级的锁管理类。在构造时锁定给定的互斥体，并在销毁时(作用域结束)自动解锁。它不可以显式解锁，也不支持锁的转移。
2. unique_lock 提供了更多的灵活性。它允许显式的锁定和解锁操作，还支持锁的所有权转移。unique_lock 可以在构造时选择不锁定互斥体，并在稍后需要时手动锁定。

```cpp
std::lock_guard<std::mutex> lock(mtx); 不能拷贝和移动
// 构造时不锁定
unique_lock<std::mutex> lock(mtx, std::defer_lock);有lock函数 
```

## 8.auto和decltype 

1. auto:用于自动推断变量的类型。编译器会根据变量的初始化表达式来推导变量的类型.
2. decltype : 用于推断表达式的类型。会返回一个表达式所对应的类型消息，而不进行计算。常用于模板编程。

## 9.如何理解C++的atomic.

用于实现原子操作，多个线程可以对同一个变量进行读写操作，不会导致数据竞争，不用锁，简化代码、提高性能。

原子操作是不可分割的操作，执行或者完全不执行。atomic使用CPU提供的原子指令来实现不可分割的操作。atomic适合简单的数据结构，例如计数器或者标志位，对于复杂的数据结构，锁的使用仍是最优选择。

## 10.C++ 中为什么要使用 nullptr 而不是NULL?

主要原因是 nullptr 有明确的类型，它是 std::nullptr_t类型，可以避免代码中出现类型不一致的问题。

## 11.tuple

**`tuple`** 可以包含任意类型和任意数量的元素，允许我们组合不同类型的数据。

可以通过 `get` 来访问和修改元组中的元素，使用 tuple_size` 获取元组的大小，使用 tuple_cat` 进行拼接，使用 `tie` 或结构化绑定来解包元组。

虽然元组可以包含大量元素，但实际应用中应避免过多元素，确保代码的可读性和维护性。

使用 `make_tuple` 或直接使用 `tuple` 构造函数创建元组。

```cpp
#include <tuple>
#include <iostream>
int main() {
 // 使用 std::make_tuple 创建元组
 auto t1 = make_tuple(10, 3.14, string("hello"));
 // 使用 std::tuple 构造函数创建元组
 tuple<int, double, string> t2(42, 6.28, "world");
 return 0;
 std::cout << get<0>(t1) << std::endl; // 10
}
```

## C++14

1. C++14 允许在 **Lambda 表达式** 中使用自动类型推导（`auto`），从而实现泛型 Lambda。使得 Lambda 可以适应不同类型的参数，而无需显式指定参数类型。
2. C++14 支持自动推导 **Lambda 表达式的返回类型**，不再需要显式指定 `->` 返回类型。
3. 在 C++11 中，`std::make_shared` 用于方便地创建 `std::shared_ptr`，但没有类似的工具函数用于 `std::unique_ptr`。C++14 引入了 **`std::make_unique`**，方便创建 **`std::unique_ptr`** 对象，并避免手动使用 `new`。
4. C++14 引入了 **`decltype(auto)`** 作为一种推导变量或返回值类型的工具。`decltype(auto)` 使用的是 `decltype` 的规则，而不是 `auto` 的规则。
   - `auto` 会移除引用和 `const`。
   - `decltype(auto)` 则会保留表达式的精确类型。
5. C++14 引入了 **`std::exchange`** 函数，它的作用是将一个对象的值替换为新值，并返回旧值。这在某些情况下可以简化代码逻辑，尤其在重置对象状态时。

## C++17

1. 结构化绑定（Structured Bindings）:pair和tuple 将它们的值绑定到多个变量。这使得从容器或函数返回多个值时更方便。

   ```cpp
   int main() {
   tuple<int, double, string> myTuple(1, 3.14, "hello");
   // 使用结构化绑定
   auto [i, d, s] = myTuple;
   cout << i << ", " << d << ", " << s << endl;
   return 0;
   }
   ```

2. `std::variant` 是一种类型安全的 **联合体（union）**，它可以存储多种不同类型的值，但在某一时刻只能存储一种类型。相比传统的联合体，`std::variant` 提供了更强的类型安全性和灵活性。

3. `std::invoke` 是一个通用调用工具，可以调用任何可调用对象（如函数、Lambda 表达式、函数对象、成员函数等），并且非常适合泛型编程。

4. `std::optional` 提供了一种类型安全的方式表示可能包含值或没有值的对象。它可以用于表示函数返回值可能为空的场景，而不需要使用指针或特殊值。

   ```cpp
   #include <optional>
   #include <iostream>
   std::optional<int> find_value(bool condition) {
       if (condition) {
           return 42;  // 有效值
       }
       return nullopt;  // 没有值
   }
   int main() {
       auto result = find_value(true);
       if (result) {
           cout << "Value: " << *result << endl;
       } else {
           cout << "No value found" << std::endl;
       }
       return 0;
   }
   ```

# STL相关

## 1.常用的STL容器有哪些？

vector、stack、priority_queue、unordered_map、unordered_set.

**`vector`**：动态数组，支持快速随机访问O(1)，插入和删除操作在末尾开销最小O(1)，中间O(n)；查找O(n)；

**`stack`**：栈，后进先出（LIFO）。基于deque，O(1)

**`priority_queue`**：优先队列，元素按优先级排序。通常基于`vector`实现，插入删除：O(log⁡n)，访问O(1)

set和map基于红黑树，插入删除访问是O(logn)

unordered_set和unordered_map是基于hashtable的。

## 2.STL容器是线程安全的吗？你怎么样在多线程的环境下使用容器？

通常，多个线程同时读取同一个STL容器是安全的，但同时进行写操作则不安全。

使用互斥锁、条件变量防止数据竞争。

## 3.vector底层实现?

std::vector 是基于动态数组实现的。它通过动态分配内存(malloc)和扩展机制来管理内存，存储元素在连续的内存块中。
`vector` 对象本身通常存储在栈上（如果是局部变量），而 `vector` 的元素存储在堆上。**vector** 在默认构造时是空的，大小为0，不会分配任何内存。

vector的pop_back底层实现？ 通过修改size的属性删除最后一个元素，调用元素的析构函数，不会改变capacity，这个内存仍然可以使用。
vector的push_back底层实现？ ①检查size是否到达capacity，如果到达就要扩容再添加，没有到达就直接添加，增加size计数。

## 4.vector的扩容机制？

vector在容量不足时，以1.5倍或2倍的增长率扩展容量。扩容时会分配新内存，复制旧数据到新内存，释放旧内存。
MSVC 会根据当前容量的大小选择不同的增长因子,如 1.5 倍或 2 倍。GCC是2倍。
reserve仅改变容量，resize改变vector的大小和容量。使用reserve分配好内存空间，避免push_back的时候动态扩容。频繁的push_back触发扩容，会导致内存碎片

## 5.为什么用倍数扩容，而不是等长个数方式扩容？为什么是1.5倍、2倍，而不是3、4倍？

等长个数方式扩容，平均下来时间复杂度为O(n);倍数扩容的复杂度为O(1);小于两倍的倍数可以复用之前释放的空间。

## 6.vector如何释放空间？

想释放多余的内存使用swap()，通过临时对象与原对象交换来释放不再使用的内存

```cpp
vector<int>().swap(vec);// 清空vec的全部空间
vector<int>(vec).swap(vec); // 清空vec的多余空间
```

shrink_to_fit释放多余的内存。

## 7.vector::at()和vector::operator[]的区别？

at()：提供边界检查，如果访问越界会抛出std::out_of_range异常。

operator[]：不提供边界检查，访问越界会导致未定义行为。 

## 8.迭代器失效了解吗？

vector在扩容后，指向旧数据的迭代器会失效。删除某个元素后，该元素及之后的元素的迭代器会失效。

set和map的插入和删除不会移动其他元素，所以其他元素迭代器保持有效。

hashtable：插入引发了重新哈希，所有的迭代器会失效。

deque：如果重新分配内存，迭代器就会失效。

## 9.迭代器的++it、it++哪个好？为什么？

++it 前置递增效率更高，因为它直接对迭代器进行递增操作，**不需要创建临时对象**；而 it++ 后置递增**需要创建临时对象**，效率较低。一般建议使用 ++it。

## 10.emplace_back()和push_back()区别?

emplace_back()用于在原地构造元素，避免了不必要的拷贝和移动操作，适用于需要高效插入复杂对象的情况。push_back() 则是将已有的元素复制或移动到 vector 的末尾。

## 11.STL迭代器和指针有什么区别？

**迭代器：**迭代器是一种抽象(类对象)的概念,它为访问容器元素提供了一种标准化的接口。迭代器可以被用来遍历、访问和修改容器中的元素。

**指针：**实际的内存地址表示，适用于数组等简单结构。

## 12.list的底层实现？

list在STL中是双向环状链表，每个结点包含一个元素和两个指针。头结点和尾结点通常有哨兵节点来简化边界条件的处理。可以在常数时间内插入和删除。

## 13.vector与list的区别？

1. vector的随机访问效率高，但在插入和删除时需要挪动数据，不易操作。
2. list的查找和访问要遍历整个链表，随机访问效率低，但对数据的插入和删除操作等都比较方便，改变指针的指向即可。
3. vector的迭代器在内存重新分配后就失效了，list的迭代器在使用之后还可以继续使用。
4. 空间开销上，list需要额外存储两个指针。

如果需要快速随机访问,使用`std::vector`比较合适;如果需要频繁插入和删除,使用`std::list`会更加高效

## 14.STL中map的实现原理

`map`的实现通常基于红黑树，这是一种自平衡的二叉搜索树。确保插入、删除和查找操作的时间复杂度都是O(log n)。

## 15.哈希表的底层实现？

1. 底层数据结构:
   哈希表通常使用一个**动态数组作为底层数据结构**。数组中的每个元素称为一个"桶"(bucket),可以存储1个或多个元素。

2. **哈希函数:**哈希函数的作用是将key计算成一个哈希值，将哈希值映射到数组索引上，以确定元素应该存储在哪个桶中。常见的映射法包括除法散列法、乘法散列法。哈希函数：SHA-256、SHA-512

3. **哈希冲突**处理:当两个不同的键值被映射到同一个桶中时,就会发生哈希冲突。常见的冲突处理方法有:链地址法、开放地址法等。

   STL中使用**链地址法**来解决哈希冲突。即每个桶存储一个链表，当哈希冲突发生时，新元素会被插入到相应桶的链表中。

   **在极端情况下，链地址法导致所有元素在一个桶里，怎么优化？**

   1. **链表替换为平衡树** 是一种最常见的优化策略，能在链表较长时显著提高性能。
   2. **降低装载因子** 通过增加桶的数量来减少冲突。
   3. **优化哈希函数** 可以从源头上减少冲突发生的概率。

   开放地址法

   1. **线性探测法**是开放地址法中的一种实现方式。当发生哈希冲突时，线性探测法会按固定步长（通常是 1）向后寻找下一个空闲的槽位来存储冲突的键。**缺点：**线性探测法容易产生**主群现象**。即，当某个槽位发生冲突后，冲突的元素会聚集在一起形成一段连续的占用槽区域。这会导致探测序列的长度增加，进而影响插入和查找的效率。
   2. **二次探测法**在发生冲突时，按二次方的步长进行跳跃探测，而不是每次线性递增 `1`。

   

4. **哈希表的动态调整**:

   1. rehash:为了保持哈希表的性能,需要动态调整哈希表大小。一般是使用素数，2倍扩容。当装载因子(load factor)超过某个阈值(0.7-0.9)时,需要对哈希表进行扩容;(负载因子是元素数量与数组大小的比值)。扩容时需要重新计算所有元素的哈希值并rehash。
   2. 桶分裂：性线性哈希（Linear Hashing）是桶分裂的一种常见实现，它通过逐步扩展哈希表，并对某些桶进行分裂来动态适应数据的增长需求。

## 16.红黑树有什么优点？

红黑树是一种自平衡二叉搜索树，保证了插入、删除和查找操作的时间复杂度为O(log n)，有效避免了退化成链表的情况。红黑树广泛用于实现有序容器，如map和set，能够保持元素的有序性。

AVL树和红黑树的区别？

1. AVL树是**严格平衡二叉树搜索树**，左右子树的高度差最多为1，超过1就要进行旋转来恢复平衡。 红黑树是弱平衡二叉树，通过控制节点颜色和数量来平衡，允许高度差更大。
2. AVL旋转更频繁。AVL严格平衡，树的高度低一点，查找性能比红黑树好
4. AVL适合查询多的场景，红黑树由于旋转次数相对较少，适合插入删除频繁的场景。

红黑树的(性质)定义：  

1. 每个节点要么是黑色，要么是红色。 
2. 根节点是黑色。
3.  每个叶子节点（NIL）是黑⾊。
4. 每个红色结点的两个子结点⼀定都是黑色。
5. 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。、
6. 所有的叶子节点都指向 `nullptr`，并且这些 `nullptr` 节点通常被认为是 **黑色**，这样可以保持红黑树的黑色高度一致性。

## 17.C++的map和unordered_map有什么区别？

| **特性**                 | **map**                    | **unordered_map**              |
| ------------------------ | -------------------------- | ------------------------------ |
| **底层实现**             | 红黑树（平衡二叉搜索树）   | 哈希表（哈希映射）             |
| **元素有序性**           | 按键值排序存储             | 元素无序存储                   |
| **查找/插入/删除复杂度** | O(log n)                   | 平均O(1)，最坏O(n)             |
| **迭代器有效性**         | 在插入和删除操作后仍然有效 | 插入和删除操作可能使迭代器失效 |
| **内存使用**             | 较高（需要额外的树结构）   | 较低（主要用于哈希桶）         |

## 18.linux的线程调度底层是不是红黑树？

1. 普通任务由 CFS(完全公平调度) 调度器管理的，CFS的底层是红黑树。CFS 的目标是提供一个公平、高效的调度机制,确保所有线程都能获得合理的 CPU 时间。
2. **红黑树在 CFS 中的应用**:
   - CFS 使用一棵红黑树来维护就绪队列中的所有线程。
   - 红黑树的关键字是线程的**虚拟运行时间**(virtual runtime)。
   - 虚拟运行时间是线程实际运行时间和其权重计算得到,反映了线程的公平性。
3. **为什么使用红黑树**:
   1. 红黑树的平衡操作确保在插入和删除线程时，树的高度保持在 O(log n)，从而保证了调度操作的高效性。

## 19.STL中deque的实现原理？

deque是双端队列，允许在两端高效的插入和删除，基于动态数组和块链表的结合，即分段连续的内存块。

1. 使用一组固定大小的内存块，每个块存储一定数量的元素。（定量连续空间、缓冲区）默认是512字节空间。
2. 这些块通过一个中央控制结构（vector）连接起来。每个元素(node)都是指针，指向1中的缓冲区。
3. 迭代器有四个指针，指向指定缓冲区的头尾，指向缓冲区的当前元素，指向控制台的node
4. 中央控制结构可以向两边扩展。

## 20.STL中list与deque之间的区别？

1. std::list 是基于双向链表实现的，适用于需要频繁在任意位置插入或删除元素的场景。
2. std::deque 是双端队列，分段连续内存布局，提供高效的随机访问和在两端进行插入和删除的高效操作。

## 21.map插入方式有哪几种？区别是什么？

m.insert(std::make_pair(key, value));

**insert**：如果 key 不存在,则插入新的键值对。如果 `key` 已存在,则不会修改元素,并返回插入结果的迭代器和布尔值，表示是否插入成功；

**operator[]**： m[key] = value; 如果 key 不存在,则会插入一个新的键值对,初始值为 value。如果 key 已存在,则会修改该键对应的值为 value。

**emplace**：m.emplace(key, value);该方法使用完美转发构造新的键值对,避免了临时对象的创建和复制。与 insert() 函数相比,在某些情况下性能会更好。

## 22.描述priority_queue的底层原理及使用场景?

**底层原理：**priority_queue是基于堆实现的，通常使用vector作为底层容器，并通过堆算法（如std::make_heap、std::push_heap和std::pop_heap）来维护堆结构。默认是大顶堆。
**使用场景：**适用于需要快速访问最大或最小元素的场景，如任务调度、事件驱动的模拟、路径规划算法(dijkstra)等。
第三个参数一般是一个函数对象，可以自定义优先级。默认是less<>;greater<>是小顶堆。
操作的时间复杂度：push-O(logn) pop-O(logn) top-O(1)

## 23.何时应使用forward_list？

需要频繁的插入和删除操作,内存受限,只需要单向遍历,并且不需要随机访问时,`std::forward_list` 可能是一个很好的选择。

## 24.什么时候会使用stack，它的底层容器是什么？

**s**td::stack 是后进先出（LIFO）的数据结构，适用于需要这种访问顺序的场景，如函数调用栈、撤销操作等。

**底层容器：**默认**使用deque作为底层容器**，但可以使用其他容器如vector或list。 使用 deque 作为底层容器时,push 和 pop 操作的时间复杂度都是 O(1)。

## 25. STL中排序算法如何工作？它们如何与容器互动？

sort：通常使用快速排序（quicksort）、堆排序（heapsort）和插入排序（insertionsort）的混合算法，适用于随机访问迭代器，如vector和deque。

stable_sort：使用归并排序，保持相同元素的相对顺序，适用于所有类型的迭代器。

list和forward_list有自己的sort成员函数。使用归并排序(merge sort)算法,时间复杂度为 O(n log n)。

## 26.C++中为什么要使用array它有什么优点?

1. 使用固定大小的栈内存。
2. 使用连续的栈内存布局，性能接近C风格的数组。
3. 类型安全。相对C风格的数组，提供了类型安全的at()接口。
4. 接口友好。提供了STL的标准接口，使用方便。
5. 可以与STL标准库功能配合使用，算法函数等。

## 27.vector和array的区别？

1. vector动态可变，array大小不可变，编译时固定。
2. vector元素存储在堆，array存储在栈或者全局内存。
3. vector大小扩展存在开销，array大小固定无开销
4. array性能优于vector

## 28.C++ 的 string 内部使用的是堆内存还是栈内存?

string的对象本身位于栈内，但它管理的字符串数据存储在堆内存。当字符串比较短的时候，大多数实现会在对象内部使用一个短字符串优化，此时字符串数据会位于栈内存。

# 其他

## 1.排序算法稳定性，哪些稳定哪些不稳定

稳定：冒泡、插入、归并、计数、基数排序、桶排序

不稳定：选择排序、快速排序、堆排序、希尔排序

## 2.为什么归并稳定，快速排序不稳定

在归并排序中，当两个元素相等时，合并算法总是优先选择左侧的元素。这意味着在合并时，原来左侧元素的相对顺序被保留。

当处理重复元素时，一个位于左侧的元素可能会被移动到右侧，而右侧的元素可能会被移动到左侧，从而改变它们的相对顺序。

## 3.nlogn复杂度的排序算法有哪些？

堆排序: 不稳定，最好平均最坏都是nlogn 空间复杂度是O1

快排: 不稳定，最好和平均是nlogn，最坏是n^2 空间复杂度 logn，最坏是n

归并: 稳定，最好平均最坏都是nlogn，空间复杂度是O(n) 自底向上不用递归O(1)

## 4.++i，i++是线程安全的吗？

不是，这个操作不是原子的，i++分为几个步骤：读取变量 i 的值。对 i 的值加1**。**将结果写回到变量 i。

## 5.大量数字的排序问题

内存不足用归并。

可以使用快排的变种，快速选择排序，有个力扣题和这个有关系

堆排序也可以

# 设计模式

**为了可重用代码、让代码更容易被他人理解、保证代码可靠性。**

## 0.六大设计原则

1. 单一职责原则（SRP - Single Responsibility Principle）
   1. 含义：一个类应只负责一个功能或职责，应该仅有一个引起它变化的原因。
   2. 目的：降低类的复杂度，增加可维护性，避免因为一个职责的变化而影响到其他职责。

2. 开放封闭原则（OCP - Open/Closed Principle）
   1. 含义：软件实体（类、模块、函数等）应对扩展开放，但对修改封闭。
   2. 目的：通过扩展现有的代码而不是修改，减少引入新错误的风险，提高系统的灵活性。

3. 里氏替换原则（LSP - Liskov Substitution Principle）

   1. 含义：子类对象必须能够替换其父类对象，并且程序的功能不受影响。
   2. 目的：确保继承关系的正确性，确保子类能够在任何父类能够使用的地方替代父类，避免破坏系统的行为。

4. 接口隔离原则（ISP - Interface Segregation Principle）

   1. 含义：不应强迫客户端依赖于它不使用的接口，即接口应尽量小而专一
   2. 目的：避免不必要的依赖，增强系统的灵活性和可维护性。

5. 依赖倒转原则（DIP - Dependency Inversion Principle）

   1. 含义：高层模块不应依赖于低层模块，二者应依赖于抽象；抽象不应依赖于细节，细节应依赖于抽象。
   2. 目的：通过依赖抽象而非具体实现，降低模块间的耦合度，提高系统的可扩展性和可维护性。

6. 合成复用原则（CRP - Composite Reuse Principle）

   1. 含义：优先使用组合/聚合，而不是继承来实现代码的复用。
   2. 目的：通过组合对象来实现复用，降低类之间的耦合度，提高灵活性。

## 单例

单例确保一个类只有一个实例。分为懒汉式单例和饿汉式单例，懒汉式单例在第一次使用时创建。**饿汉式单例**的实例在类加载时就创建。避免了实例化多个对象所带来的资源浪费。

单例与静态变量的区别？

1. 单例用于确保一个类只有一个实例。静态变量是为了维持某个对象的持久状态。
2. 单例用函数获取；静态变量用类+::
3. 静态变量的对象

## 工厂模式

工厂模式通过将对象的创建过程封装在工厂类中，**使得客户端代码与具体的实现类解耦**，从而提高代码的灵活性和可扩展性。简单工厂模式在添加产品的时候需要修改代码，工厂方法模式用抽象工厂管理产品，可以添加而不修改具体代码。

## 观察者

观察者模式：定义了一种一对多的依赖关系，使得多个观察者对象可以监听一个主题对象。观察者可以注册到某个主题上，当该主题发生变化时，会通知所有注册的观察者。

## 1.设计模式分类

1. 创建型模式 :主要解决如何灵活创建对象或者类的问题
   1. 工厂模式：定义一个创建对象的接口，但将对象的实际创建延迟到子类。
   2. 抽象工厂模式：提供一个创建相关对象家族的接口，而无需指定具体类。
   3. 单例：确保一个类只有一个实例，并提供全局访问点。
   4. 建造者模式：将一个复杂对象的构建过程分解为多个步骤，以便更灵活地创建对象。
   5. 原型模式：通过复制现有对象来创建新对象，而不是从头开始构建。
2. 结构型模式 :结构型设计模式主要用于将类或对象进行组合从而构建灵活而高效的结构。 代理模式。
3. 行为型模式 :行为型设计模式主要解决类或者对象之间互相通信的问题。观察者模式。

## 2.设计模式的优点
1.  **代码可复用性**

   设计模式为开发人员提供了一种解决常见问题的模板，减少了代码冗余。通过设计模式，可以在不同项目中复用解决方案，提高开发效率和代码质量。

 2. **代码可读性和可维护性**

    设计模式的命名和结构易于理解，它们为复杂系统提供了一种有组织的方式。团队成员能快速理解代码背后的设计思路，**使代码更易于维护和扩展。**

    设计模式有助于规范代码结构，使得开发团队能在代码风格和架构上保持一致性。

  3. **降低耦合性**

     设计模式通过定义接口和抽象，降低了模块之间的耦合度。使用合适的设计模式可以将对象或模块之间的依赖最小化，从而提高系统的灵活性和可扩展性。

  4. **提高代码的可扩展性**

     设计模式能够提供一种灵活的框架，使得系统可以随着需求变化轻松进行扩展。例如，使用**装饰者模式**可以动态地给对象添加功能，使用**工厂模式**可以方便地引入新类型。

